
# AI Home Builder - Project Documentation

## 1. Current Application Architecture (Phase 2)
The application has evolved into a smart **Construction Engine**. It no longer just plays back a hard-coded animation; it analyzes architectural data and determines *how* to build the structure procedurally.

### Core Concepts

*   **The Director (`App.tsx`):** 
    *   Manages the high-level state (e.g., "Is the house currently built?").
    *   Coordinate the UI and the 3D Experience.

*   **The Stage (`Experience.tsx`):**
    *   Sets up the physical environment (Sun, Sky, Ground, Fog).
    *   Defines the "Construction Zone" where the engine operates.

*   **The Blueprint (`data/mockHouse.ts`):**
    *   Pure architectural data.
    *   It lists *what* parts exist (Walls, Floor, Roof) but contains **no animation logic**.
    *   It defines physical properties: position, size, material type.

*   **The Engine (`House.tsx`):**
    *   This is the brain of the operation.
    *   It receives the Blueprint.
    *   **Sorting:** It categorizes components based on structural priority (Foundation first, then Walls, then Roof).
    *   **Scheduling:** It calculates the exact timestamp (`renderDelay`) for when each part should appear to create a smooth, staggered construction effect.

*   **Atomic Components (`components/structure/*`):**
    *   Dumb 3D blocks (`Block.tsx`, `Roof.tsx`).
    *   They receive a target size and a `renderDelay` from the Engine.
    *   They use a custom hook `useBuildingAnimation` to handle the physics of "popping in" at the correct time.

---

## 2. Data Flow Diagram

The following diagram illustrates how raw JSON data is transformed into a sequenced 3D animation.

```mermaid
graph TD
    %% Data Layer
    Data[Blueprint JSON] -->|Props: components[]| Engine[House Engine Component]

    %% Logic Layer (House.tsx)
    subgraph "Construction Sequencer (House.tsx)"
        Engine -->|Step 1| Sorter{Priority Sorter}
        Sorter -->|Priority 0| Floor[Floors]
        Sorter -->|Priority 1| Wall[Walls]
        Sorter -->|Priority 2| Roof[Roof]
        Sorter -->|Priority 3| Detail[Windows/Doors]
        
        Floor -->|Step 2: Calculate Timing| Scheduler[Time Scheduler]
        Wall --> Scheduler
        Roof --> Scheduler
        Detail --> Scheduler
    end

    %% Rendering Layer
    subgraph "Visual Layer"
        Scheduler -->|Prop: renderDelay=0.0s| Block1[<Block /> Foundation]
        Scheduler -->|Prop: renderDelay=0.5s| Block2[<Block /> Walls]
        Scheduler -->|Prop: renderDelay=1.0s| Block3[<Roof /> Roof]
        
        Block1 -->|Hook| Anim[useBuildingAnimation]
        Block2 -->|Hook| Anim
        Block3 -->|Hook| Anim
        
        Anim -->|Ref| ThreeJS[Three.js Scene Graph]
    end
    
    style Data fill:#f9f,stroke:#333,stroke-width:2px
    style Engine fill:#bbf,stroke:#333,stroke-width:2px
    style ThreeJS fill:#bfb,stroke:#333,stroke-width:2px
```

---

## 3. Future Vision: Text-to-3D Home Generation
The ultimate goal is to move from a hard-coded house to a dynamic one generated by Artificial Intelligence based on user input.

### The Concept
Instead of clicking a button to spawn a *pre-defined* house, the user will type a prompt, and the application will build a unique structure matching that description.

**User Journey:**
1.  User types: *"I want a modern 2-story minimalist house with large windows and a flat roof."*
2.  **AI Processing:** The system interprets this text.
3.  **Visualization:** The house constructs itself component-by-component in the 3D scene.

### How to Implement (The "JSON Blueprint" Strategy)
We should not ask the AI to write 3D code directly (which is error-prone). Instead, we will ask the AI to generate a **Blueprint (JSON Data)**.

**Proposed Workflow:**

1.  **Input:** User Prompt sent to LLM (Gemini API).
2.  **Translation:** The LLM returns a structured JSON object.
    *   *Example Response:*
        ```json
        {
          "style": "modern",
          "floors": 2,
          "roof": { "type": "flat", "color": "#333" },
          "walls": { "color": "#white", "width": 10, "depth": 8 },
          "windows": ["large-glass-panel", "large-glass-panel"]
        }
        ```
3.  **Rendering:** The React application reads this JSON.
    *   `if (roof.type === 'flat') return <FlatRoof />`
    *   `if (floors === 2) return <SecondStory />`

This makes the system **Deterministic** (reliable) but **Infinite** (endless variations).

---

## 4. Feature Enhancements & Roadmap

### Phase 1: Enhanced Environment (Visuals) - **COMPLETED**
*   **Dynamic Day/Night Cycle:** Change the sun position based on a slider.
*   **Vegetation:** Procedurally place trees and bushes around the house zone.
*   **Terrain:** Add slight elevations or landscaping rather than a perfectly flat plane.

### Phase 2: The Architect Engine (Logic) - **IN PROGRESS**
*   **Modular Component System:** Break the `House.tsx` into smaller reusable lego blocks (`<Wall />`, `<Window />`, `<Door />`, `<Roof />`).
*   **Sequencer:** Logic to ensure parts build in the correct order (Foundation -> Roof).

### Phase 3: AI Integration (Intelligence)
*   **Prompt Interface:** Add a text input field to the UI Overlay.
*   **Blueprint Parser:** A function that takes AI JSON output and maps it to the Modular Component System.

### Phase 4: Interaction (UX)
*   **Interior Mode:** Allow the camera to zoom inside the house.
*   **Material Swapping:** Click on a wall to change it from Brick to Wood.
*   **Export:** A button to download the house as a `.obj` file for 3D printing or use in other software.
